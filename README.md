# 🖥️ Dynamic Branch Prediction Simulation Assignment - SimpleScalar

## 📚 ELE336-Computer Architecture
## 👨‍🏫 DR. MAY MOHAMED

### 👥 Team Members:
- OMAR AHMED ABDELAZIZ 
- ALI MOHAMED
- ALI MARIOS MAGED
- HAGAR ALI
- HANA AHMED

## 1. 🔍 Definition of Simulation Problem

This assignment involves evaluating the performance of different dynamic branch prediction schemes using the SimpleScalar sim-outorder simulator. The main objectives of the assignment are:

- 🔧 Configure the sim-outorder simulator to match specific computer system parameters
- 📈 Analyze branch frequency and characteristics in SPEC95 benchmark applications
- 🔄 Compare the effectiveness of three branch prediction strategies:
  - ⚡ Static prediction (backward branches taken, forward branches not taken)
  - 🔢 2-bit dynamic branch prediction
  - 🧠 Correlating branch prediction

The simulation is set to model a basic processor that executes one instruction at a time with specific cache, TLB, and memory configurations. We need to analyze branch frequency, branch characterization, and prediction accuracy for each scheme.

## 2. ⚠️ Problems Encountered

During the implementation and analysis of this assignment, we faced several challenges:

1. **🛠️ Setting up SimpleScalar environment**: The initial configuration of the simulator required understanding a complex set of parameters and ensuring they matched the assignment specifications exactly. The configuration flags needed precise values to match the required computer configuration.

2. **📝 Simulator output interpretation**: Understanding the extensive statistics generated by the SimpleScalar simulator (as seen in sim-2lev.txt) required careful analysis to extract the right metrics for our branch prediction study.

3. **🔍 Branch characterization analysis**: Determining the frequency of forward/backward and taken/not-taken branches required additional stats that weren't immediately available in the default output. We needed to configure additional simulation parameters.

4. **📏 History bits limitation analysis**: Designing experiments to test the limits of useful history bits while keeping all other factors constant proved challenging. We needed to understand the trade-offs between prediction accuracy and implementation complexity.

5. **🧩 Correlating branch prediction implementation**: Understanding the specifics of the 2-level branch predictor configuration (1 1024 8 0) required careful study of the SimpleScalar documentation to interpret what these parameters meant for our simulation.

## 3. 💡 How We Solved Them

1. **⚙️ SimpleScalar Setup**:
   - Created a consistent configuration file with all required parameters based on assignment specifications
   - Used the command line: `./sim-outorder -fetch:ifqsize 1 -decode:width 1 -issue:width 1 -issue:inorder true -res:ialu 1 -res:imult 1 -res:memport 1 -res:fpalu 1 -res:fpmult 1 -bpred 2lev -cache:dl1 dl1:128:32:2:l -cache:il1 il1:128:32:2:l -cache:dl2 ul2:8192:32:1:l -tlb:itlb itlb:16:4096:4:l -tlb:dtlb dtlb:16:4096:8:l`
   - Validated the configuration by checking simulator output for expected architecture details

2. **📊 Simulator Output Interpretation**:
   - Analyzed the comprehensive statistics in sim-2lev.txt to extract relevant branch prediction metrics
   - Calculated derived metrics such as branch frequency and prediction accuracy
   - Created a systematic approach to compare metrics across different branch prediction schemes

3. **📋 Branch Characterization**:
   - Used metrics like `bpred_2lev.addr_hits` and `bpred_2lev.dir_hits` to understand prediction performance
   - Developed scripts to categorize branches by direction and outcome
   - Cross-referenced branch prediction rates with our expectations based on branch behavior

4. **📈 History Bits Analysis**:
   - Systematically modified the `bpred:2lev` parameter to test different history bit configurations
   - For example, changed `-bpred:2lev 1 1024 8 0` to test different history register widths (8)
   - Analyzed the diminishing returns on prediction accuracy with increasing history bit count

5. **🧮 2-Level Branch Predictor Understanding**:
   - Studied the SimpleScalar documentation to understand the 2-level predictor configuration (1 1024 8 0):
     - 1: Number of entries in first level (shift registers)
     - 1024: Number of entries in second level (pattern history table)
     - 8: Width of shift register (history bits)
     - 0: Not using XOR for indexing (0 = no, 1 = yes)
   - This configuration represents a GAp predictor with 1 global history register of 8 bits and a 1024-entry pattern history table

## 4. 📊 Output Samples

### 📊 Branch Frequency Analysis
```
# Branch frequency results based on sim-2lev.txt
Total instructions executed:  1,380,934
Total branches executed:        347,377
Branch frequency:               25.16%
Branches per instruction:       1 branch every 3.98 instructions
```

This analysis shows a branch frequency significantly higher than the typical average of 1 branch every 4-6 instructions mentioned in the assignment, suggesting that the test program has more conditional logic than typical applications.

### 🎯 Branch Prediction Accuracy (2-level predictor)
```
# Detailed branch prediction statistics from sim-2lev.txt
Total branch lookups:         348,156
Total branch updates:         346,652
Direction-predicted hits:     337,920
Total misses:                   8,732
Branch prediction rate:        97.48%
```

The 2-level branch predictor configuration shows excellent prediction accuracy at 97.48%, demonstrating the effectiveness of this prediction method for the test benchmark.

### 💾 Cache Performance
```
# Cache statistics from sim-2lev.txt
                | Access Count | Hit Rate | Miss Rate
----------------|--------------|----------|----------
L1 Instruction  |    1,446,435 |  95.78%  |   4.22%
L1 Data         |      475,395 |  99.90%  |   0.10%
L2 Unified      |       61,797 |  98.00%  |   2.00%
```

These cache statistics show that our configuration is performing well, with particularly low miss rates in the data cache.

### ⚡ Simulation Performance
```
# Overall simulation performance metrics
Instructions Per Cycle (IPC):  0.6031
Cycles Per Instruction (CPI):  1.6582
Simulation time (cycles):    2,280,872
```

The IPC of 0.6031 indicates that our single-issue in-order processor configuration is executing approximately 0.6 instructions per cycle, which is reasonable for this architecture.

### 🔄 Branch Target Buffer Performance
```
# Branch Target Buffer statistics
JR address-prediction rate:     97.82%
Return Address Stack hits:      18,397
Return Address Stack rate:      99.95%
```

The Return Address Stack is performing exceptionally well with a hit rate of nearly 100%, which significantly improves the prediction of function return addresses.

This README provides an overview of our approach to the dynamic branch prediction simulation assignment, highlighting both the challenges we faced and the solutions we implemented to complete the analysis successfully.